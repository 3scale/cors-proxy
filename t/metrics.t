BEGIN {
    $ENV{TEST_NGINX_APICAST_BINARY} ||= 'rover exec apicast-cli';
}

use lib 't';
use Test::APIcast::Blackbox 'no_plan';

push @Test::Nginx::Util::BlockPreprocessors, sub {
    my $block = shift;

    my %env = $block->env;
    my $lua_env = '';
    for my $key (keys %env) {
        $lua_env .= " { name = '$key', value = '$env{$key}' } ,";
    }

    my $Workers = $Test::Nginx::Util::Workers;
    my $MasterProcessEnabled = $Test::Nginx::Util::MasterProcessEnabled;
    my $DaemonEnabled = $Test::Nginx::Util::DaemonEnabled;
    my $err_log_file = $block->error_log_file || $Test::Nginx::Util::ErrLogFile;
    my $LogLevel = $Test::Nginx::Util::LogLevel;
    my $PidFile = $Test::Nginx::Util::PidFile;
    my $AccLogFile = $Test::Nginx::Util::AccLogFile;
    my $ServerPort = $Test::Nginx::Util::ServerPort;
    my $sites_d = $block->sites_d;

    my $environment= <<_EOC_;
return {
    worker_processes = '$Workers',
    master_process = '$MasterProcessEnabled',
    daemon = '$DaemonEnabled',
    error_log = '$err_log_file',
    log_level = '$LogLevel',
    lua_path = '$ENV{LUA_PATH}',
    lua_cpath = '$ENV{LUA_CPATH}',
    pid = '$PidFile',
    lua_code_cache = 'on',
    access_log = '$AccLogFile',
    port = '$ServerPort',
    metrics_port = '$ServerPort',
    env = { $lua_env },
    sites_d = [============================[$sites_d]============================],
}
_EOC_

    $block->set_value("environment",$environment);
};

delete $ENV{DATABASE_URL};

repeat_each(1);
run_tests();

__DATA__

=== TEST 1: GET /metrics
Responds with prometheus metrics
--- request
GET /metrics
--- more_headers
Host: metrics
--- response_body
# HELP nginx_http_connections Number of HTTP connections
# TYPE nginx_http_connections gauge
nginx_http_connections{state="accepted"} 0
nginx_http_connections{state="active"} 1
nginx_http_connections{state="handled"} 0
nginx_http_connections{state="reading"} 0
nginx_http_connections{state="total"} 0
nginx_http_connections{state="waiting"} 0
nginx_http_connections{state="writing"} 1
# HELP nginx_metric_errors_total Number of nginx-lua-prometheus errors
# TYPE nginx_metric_errors_total counter
nginx_metric_errors_total 0
--- error_code: 200



=== TEST 2: GET /metrics with blacklist info
cors_proxy_status{status="503"} shows request was blacklisted
--- pipelined_requests eval
["GET /t",
"GET /metrics"]
--- more_headers eval
["X-ApiDocs-URL: http://test:$ENV{TEST_NGINX_SERVER_PORT}/t", "Host: metrics"]
--- response_body eval
[qr//,
<<BODY
# HELP cors_proxy_status HTTP status generated by CORS proxy
# TYPE cors_proxy_status counter
cors_proxy_status{status="503"} 1
# HELP nginx_http_connections Number of HTTP connections
# TYPE nginx_http_connections gauge
nginx_http_connections{state="accepted"} 0
nginx_http_connections{state="active"} 1
nginx_http_connections{state="handled"} 0
nginx_http_connections{state="reading"} 0
nginx_http_connections{state="total"} 0
nginx_http_connections{state="waiting"} 0
nginx_http_connections{state="writing"} 1
# HELP nginx_metric_errors_total Number of nginx-lua-prometheus errors
# TYPE nginx_metric_errors_total counter
nginx_metric_errors_total 0
BODY
]
--- error_code eval
[503, 200 ]



=== TEST 3: GET /metrics with successful upstream request
Upstream status is correctly recorded.
--- env eval
( 'CORS_PROXY_BALANCER_WHITELIST' => '127.0.0.1/32' )
--- request eval
["GET /t", "GET /metrics"]
--- more_headers eval
["X-ApiDocs-URL: http://test:$ENV{TEST_NGINX_SERVER_PORT}/t", 'Host: metrics']
--- upstream
location = /t {
  echo_status 201;
  echo "ok";
}
--- response_body eval
["ok\n",
<<BODY
# HELP nginx_http_connections Number of HTTP connections
# TYPE nginx_http_connections gauge
nginx_http_connections{state="accepted"} 0
nginx_http_connections{state="active"} 2
nginx_http_connections{state="handled"} 0
nginx_http_connections{state="reading"} 0
nginx_http_connections{state="total"} 0
nginx_http_connections{state="waiting"} 1
nginx_http_connections{state="writing"} 1
# HELP nginx_metric_errors_total Number of nginx-lua-prometheus errors
# TYPE nginx_metric_errors_total counter
nginx_metric_errors_total 0
# HELP upstream_status HTTP status from upstream servers
# TYPE upstream_status counter
upstream_status{status="201"} 1
BODY
]
--- error_code eval
[201, 200]
--- no_error_log
[error]
